#!/usr/bin/env python3
# vim: set filetype=python

"""
Author: Scott MacDonald

This script performs actions on behalf of the dotfiles checkout.
"""

from dataclasses import dataclass
from pathlib import Path

import argparse
import logging
import os
import subprocess
import sys


logger = logging.getLogger(__name__)


# TODO: allow user to pass path to the dotfile dir as an argument
# TODO: action to produce a "bundle" of the dotfiles directory as a tar/zip
#       (this should include any externally downloaded files from setup)


def main() -> None:
    """
    Application entry point.
    """

    # Parse parameters.
    argparser = argparse.ArgumentParser()
    subparser = argparser.add_subparsers(dest="command")
    
    argparser.add_argument("-v", "--verbose", action='store_true', help='Enable verbose output (DEBUG level logging)')

    path_command = subparser.add_parser(
        "path", help="Show the path to the dotfiles checkout"
    )
    status_command = subparser.add_parser(
        "syncstate", help="Display information about the state of the git checkout"
    )
    update_command = subparser.add_parser(
        "update", help="Update the dotfiles checkout with upstream changes"
    )

    args = argparser.parse_args()

    # Logging setup.
    if args.verbose:
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.INFO)

    # Execute requested command.
    if args.command == "syncstate": 
        if not status_cmd():
            sys.exit(1)
    elif args.command == "path":
        print(get_dotfiles_dir())
    elif args.command == "update":
        if not update_cmd():
            sys.exit(1)
    else:
        # default (no command) is to show repo info and change state.
        print(get_dotfiles_dir())
        sys.exit(status_cmd())

def status_cmd() -> bool:
    repo_status = RepoCheckoutStatus.from_dir(get_dotfiles_dir())
    ahead = repo_status.commits_ahead
    behind = repo_status.commits_behind

    if repo_status.is_clean():
        print(f"local dotfiles is up to date and has no local uncommitted changes")
        return True

    if ahead != 0 or behind != 0:
        print(
            f"Local dotfiles is {ahead} commits ahead and {behind} commits behind origin"
        )

    if repo_status.has_uncommitted_changes():
        print("There are uncommitted changes in the local dotfiles checkout: ")
        for line in repo_status.uncommitted_files:
            print(f"\t{line}")

    return False

def update_cmd() -> bool:
    logger.debug("fetching git updates from origin")
    result = subprocess.run(["git", "fetch", "origin"], check=False)
    
    if result.returncode != 0:
        logger.warning(f"Errors encountered when running `git fetch origin`! Please update manually")
        return False

    logger.debug("rebasing on changes from origin/master")
    result = subprocess.run(["git", "rebase", "origin/master"], check=False)

    if result.returncode != 0:
        logger.warning("Errors encountered when running `git rebase origin/master`. Please rebase manually")
        return False

    # TODO: Check if/how many updates were pulled
    logger.info("dotfiles repo updated with changes from `origin/master`")
    return True


def get_dotfiles_dir() -> Path | None:
    dotfile_dir = os.getenv("S_DOTFILE_ROOT", None)
    root_dotfile_dir = os.path.join(os.path.expanduser("~"), ".dotfiles")

    if dotfile_dir:
        if not os.path.isdir(dotfile_dir):
            logger.error(f"env var S_DOTFILE_ROOT is not a directory: {dotfile_dir}")
            return None
    elif os.path.isdir(root_dotfile_dir):
        dotfile_dir = root_dotfile_dir
    else:
        logger.error("could not find the dotfiles checkout")
        return None

    if not os.path.exists(os.path.join(dotfile_dir, ".__dotfiles_root__")):
        logger.error(f"not a dotfiles root: {dotfile_dir}")
        return None

    return Path(dotfile_dir)


def is_valid_repo(repo_dir: Path) -> bool:
    result = subprocess.run(
        ["git", "-C", repo_dir, "remote", "get-url", "origin"],
        capture_output=True,
        text=True,
        check=True,
    )

    return result.stdout.endswith("dotfiles.git")


# TODO: add remote origin name.


@dataclass
class RepoCheckoutStatus:
    """Information about a Git repository checkout."""

    """The number of commits in this checkout that have not been pushed to origin."""
    commits_ahead: int

    """The number of commits in origin that have not been pulled to this checkout."""
    commits_behind: int

    """The list of files in this checkout that have not been committed."""
    uncommitted_files: list[str]

    def is_clean(self) -> bool:
        """
        Checks if the local repository has any uncommited changes (false) or is ahead/behind on any
        commits (false). If none of these conditions apply then `True` is returned.
        """
        return (
            self.commits_ahead == 0
            and self.commits_behind == 0
            and len(self.uncommitted_files) == 0
        )

    def has_uncommitted_changes(self) -> bool:
        return len(self.uncommitted_files) > 0

    @staticmethod
    def from_dir(repo_dir: Path) -> "RepoCheckoutStatus":
        # Calculate the number of commits ahead and behind this checkout is.
        # Ref: https://stackoverflow.com/a/27940027
        result = subprocess.run(
            ["git", "rev-list", "--left-right", "--count", "master...origin/master"],
            capture_output=True,
            text=True,
            check=True,
        )

        parts = result.stdout.split()  # <AHEAD>      <BEHDIN>
        assert len(parts) == 2

        ahead = int(parts[0])
        behind = int(parts[1])

        # Check if there are uncommited changes in the repository.
        # Ref: https://stackoverflow.com/a/62768943
        result = subprocess.run(
            [
                "git",
                "status",
                "--porcelain=v1",
            ],  # prints machine readable uncommited files
            capture_output=True,
            text=True,
            check=True,
        )

        uncommitted_files = result.stdout.splitlines()

        return RepoCheckoutStatus(
            commits_ahead=ahead,
            commits_behind=behind,
            uncommitted_files=uncommitted_files,
        )


if __name__ == "__main__":
    main()
