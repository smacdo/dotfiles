#!/usr/bin/env python3
# vim: set filetype=python

"""
Author: Scott MacDonald

This script performs actions on behalf of the dotfiles checkout.
"""

from dataclasses import dataclass
from pathlib import Path

import argparse
import logging
import os
import subprocess
import sys


logger = logging.getLogger(__name__)


# TODO: allow user to pass path to the dotfile dir as an argument
# TODO: action to produce a "bundle" of the dotfiles directory as a tar/zip
#       (this should include any externally downloaded files from setup)


def main() -> None:
    """
    Application entry point.
    """

    argparser = argparse.ArgumentParser()
    subparser = argparser.add_subparsers(dest="command")

    path_command = subparser.add_parser(
        "path", help="Show the path to the dotfiles checkout"
    )
    status_command = subparser.add_parser(
        "status", help="Info on the dotfiles checkout"
    )

    args = argparser.parse_args()

    if args.command == "status":
        repo_status = RepoCheckoutStatus.from_dir(get_dotfiles_dir())
        ahead = repo_status.commits_ahead
        behind = repo_status.commits_behind

        if repo_status.is_clean():
            print(f"local dotfiles is up to date and has no local uncommitted changes")
        elif ahead != 0 or behind != 0:
            print(
                f"Local dotfiles is {ahead} commits ahead and {behind} commits behind origin"
            )
            sys.exit(1)
        elif repo_status.has_uncommitted_changes():
            print("There are uncommitted changes in the local dotfiles checkout: ")
            for line in repo_status.uncommitted_files:
                print(f"\t{line}")
            sys.exit(1)
        else:
            raise Exception("unhanlded condition for why repo is not clean")
    else:
        # default is the path command
        print(get_dotfiles_dir())


def get_dotfiles_dir() -> Path | None:
    dotfile_dir = os.getenv("S_DOTFILE_ROOT", None)
    root_dotfile_dir = os.path.join(os.path.expanduser("~"), ".dotfiles")

    if dotfile_dir:
        if not os.path.isdir(dotfile_dir):
            logger.error(f"env var S_DOTFILE_ROOT is not a directory: {dotfile_dir}")
            return None
    elif os.path.isdir(root_dotfile_dir):
        dotfile_dir = root_dotfile_dir
    else:
        logger.error("could not find the dotfiles checkout")
        return None

    if not os.path.exists(os.path.join(dotfile_dir, ".__dotfiles_root__")):
        logger.error(f"not a dotfiles root: {dotfile_dir}")
        return None

    return Path(dotfile_dir)


def is_valid_repo(repo_dir: Path) -> bool:
    result = subprocess.run(
        ["git", "-C", repo_dir, "remote", "get-url", "origin"],
        capture_output=True,
        text=True,
        check=True,
    )

    return result.stdout.endswith("dotfiles.git")


# TODO: add remote origin name.


@dataclass
class RepoCheckoutStatus:
    """Information about a Git repository checkout."""

    """The number of commits in this checkout that have not been pushed to origin."""
    commits_ahead: int

    """The number of commits in origin that have not been pulled to this checkout."""
    commits_behind: int

    """The list of files in this checkout that have not been committed."""
    uncommitted_files: list[str]

    def is_clean(self) -> bool:
        """
        Checks if the local repository has any uncommited changes (false) or is ahead/behind on any
        commits (false). If none of these conditions apply then `True` is returned.
        """
        return (
            self.commits_ahead == 0
            and self.commits_behind == 0
            and len(self.uncommitted_files) == 0
        )

    def has_uncommitted_changes(self) -> bool:
        return len(self.uncommitted_files) > 0

    @staticmethod
    def from_dir(repo_dir: Path) -> "RepoCheckoutStatus":
        # Calculate the number of commits ahead and behind this checkout is.
        # Ref: https://stackoverflow.com/a/27940027
        result = subprocess.run(
            ["git", "rev-list", "--left-right", "--count", "master...origin/master"],
            capture_output=True,
            text=True,
            check=True,
        )

        parts = result.stdout.split()  # <AHEAD>      <BEHDIN>
        assert len(parts) == 2

        ahead = int(parts[0])
        behind = int(parts[1])

        # Check if there are uncommited changes in the repository.
        # Ref: https://stackoverflow.com/a/62768943
        result = subprocess.run(
            [
                "git",
                "status",
                "--porcelain=v1",
            ],  # prints machine readable uncommited files
            capture_output=True,
            text=True,
            check=True,
        )

        uncommitted_files = result.stdout.splitlines()

        return RepoCheckoutStatus(
            commits_ahead=ahead,
            commits_behind=behind,
            uncommitted_files=uncommitted_files,
        )


if __name__ == "__main__":
    main()
