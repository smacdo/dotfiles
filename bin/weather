#!/usr/bin/env python3
# vim: set ft=python

from __future__ import annotations
from typing import List, Literal, Optional, Union

from datetime import datetime
from enum import Enum
from pprint import pprint

import argparse
import json
import logging
import re
import sys
import urllib.request

# NOAA:
# https://www.weather.gov/documentation/services-web-api

# note: response conteains urls for forecast
#
# Also get alerts
# https://api.weather.gov/alerts/active?area={state}
# active=true
#
# Also consider air quality


class GridPoint:
    """Stores a NOAA "gridpoint" which describes a queryable weather region."""

    grid_id: str
    x: int
    y: int

    def __init__(self, grid_id: str, x: int, y: int) -> None:
        self.grid_id = grid_id
        self.x = x
        self.y = y


class TemperatureType(Enum):
    """Describes a unit of measurement for temperature"""

    f = "f"
    c = "c"


def parse_temperature_type(_type: str) -> TemperatureType:
    """Reads a character 'f' or 'c' and converts it to `TemperatureType."""
    if _type == "f" or _type == "F":
        return TemperatureType.f
    elif _type == "c" or _type == "C":
        return TemperatureType.c
    else:
        assert False, f"Invalid temperature type {_type}"


class Temperature:
    """Stores a temperature value and associated unit of measurement."""

    value: float
    _type: TemperatureType

    def __init__(self, value: float, _type: Union[str, TemperatureType]) -> None:
        self.value = value
        self._type = (
            _type
            if isinstance(_type, TemperatureType)
            else parse_temperature_type(_type)
        )

    def __str__(self) -> str:
        c = "f" if self._type == TemperatureType.f else "c"
        return f"{self.value:.2g}Â°{c}"

    def f(self) -> Temperature:
        """Returns a copy of this temperature converted to f."""
        if self._type == TemperatureType.f:
            return Temperature(self.value, TemperatureType.f)
        else:
            return Temperature(self.value * 1.8 + 32.0, TemperatureType.f)

    def c(self) -> Temperature:
        """Returns a copy of this temperature converted to c."""
        if self._type == TemperatureType.f:
            return Temperature((self.value - 32.0) / 1.8, TemperatureType.c)
        else:
            return Temperature(self.value, TemperatureType.c)


class WindSpeed:
    """Stores a [minimum, maximum] wind speed as well as direction in mph."""

    min_speed: float
    max_speed: float
    direction: str

    def __init__(self, min_speed: float, max_speed: float, direction: str):
        self.min_speed = min_speed
        self.max_speed = max_speed
        self.direction = direction

    def __str__(self) -> str:
        if self.min_speed == self.max_speed:
            return f"{self.direction} {self.min_speed} mph"
        else:
            return f"{self.direction} {self.min_speed} to {self.max_speed} mph"

    @staticmethod
    def from_str(s: str, direction: str) -> Optional[WindSpeed]:
        regex = re.compile("^(?P<min_s>\\d+)( to (?P<max_s>\\d+))? mph$")
        matches = regex.match(s)

        if matches:
            min_s = matches.group("min_s")
            max_s = matches.group("max_s")

        if min_s and max_s:
            return WindSpeed(float(min_s), float(max_s), direction)
        else:
            return WindSpeed(float(min_s), float(min_s), direction)


def read_unit_percent(json: dict) -> Optional[float]:
    """Reads a WMO percent unit from { "value": 12.3, "unitCode": "wmoUnit:percent" }"""
    if json["value"] == None or json["unitCode"] != "wmoUnit:percent":
        return None
    else:
        return float(json["value"])


def read_unit_temperature(json: dict) -> Optional[Temperature]:
    """Reads a WMO temperature unit from { "value": ..., "unitCode": "wmoUnit:degC|degF" }"""
    if json["value"] == None:
        return None
    elif json["unitCode"] == "wmoUnit:degC":
        return Temperature(float(json["value"]), TemperatureType.c)
    elif json["unitCode"] == "wmoUnit:degF":
        return Temperature(float(json["value"]), TemperatureType.f)
    else:
        return None


class ForecastPeriod:
    """Weather forecast data for a period of time."""

    name: str
    start_time: datetime
    end_time: datetime
    is_daytime: Optional[bool]
    temperature: Temperature
    precip_chance: Optional[float]
    dewpoint: Optional[Temperature]
    relative_humidity: Optional[float]
    wind: Optional[WindSpeed]
    icon_url: str
    short_forecast: str
    detailed_forecast: str

    def __init__(self, json: dict) -> None:
        self.name = json["name"]
        self.start_time = datetime.fromisoformat(json["startTime"])
        self.end_time = datetime.fromisoformat(json["endTime"])
        self.is_daytime = bool(json["isDaytime"])
        self.temperature = Temperature(json["temperature"], json["temperatureUnit"])
        self.precip_chance = read_unit_percent(json["probabilityOfPrecipitation"])
        self.dewpoint = read_unit_temperature(json["dewpoint"])
        self.relative_humidity = read_unit_percent(json["relativeHumidity"])
        self.wind = WindSpeed.from_str(json["windSpeed"], json["windDirection"])
        self.icon_url = str(json["icon"])
        self.short_forecast = str(json["shortForecast"])
        self.detailed_forecast = str(json["detailedForecast"])

    def debug_print(self):
        print(f"ForecastPeriod")
        for p in vars(self).items():
            print(f"\t{p}")


def lookup_noaa_grid_points(lat: float, long: float) -> GridPoint:
    # TODO: Error handling eg invalid lat/long.
    response_bytes = urllib.request.urlopen(
        f"https://api.weather.gov/points/{lat},{long}"
    ).read()

    # TODO: Handle JSON decoding failures.
    # TODO: Check and handle if response is unexpected.
    response = json.loads(str(response_bytes, "utf-8"))
    props = response["properties"]

    return GridPoint(props["gridId"], int(props["gridX"]), int(props["gridY"]))


def get_forecast(location: GridPoint) -> List[ForecastPeriod]:
    # TODO: Error handling eg invalid lat/long.
    url = f"https://api.weather.gov/gridpoints/{location.grid_id}/{location.x},{location.y}/forecast"
    print(url)
    response_bytes = urllib.request.urlopen(url).read()

    # TODO: Handle JSON decoding failures.
    # TODO: Check and handle if response is unexpected.
    response = json.loads(str(response_bytes, "utf-8"))

    # TODO: capture remainder of fields and encapsulate into class:
    props = response["properties"]
    generated_at = props["generatedAt"]  # "2023-09-19T17:52:33+00:00",
    update_time = props["updateTime"]  # ^^^^
    valid_time = props["validTimes"]  # "2023-09-19T11:00:00+00:00/P7DT14H"
    elevation = props["elevation"]["value"]  # 456.8951999
    # also unitCode = "wmoUnit:m" along with value

    forecasts: List[ForecastPeriod] = []
    for p in response["properties"]["periods"]:
        forecasts.append(ForecastPeriod(p))
        ForecastPeriod(p).debug_print()

    return forecasts


def main():
    # Parse command line options.
    args_parser = argparse.ArgumentParser(description="does neat stuff")

    args_parser.add_argument("-l", "--location")
    args_parser.add_argument("--cache_time_secs", default=10 * 60)

    args = args_parser.parse_args()

    # print("the weather is: ")
    # print(get_weather_data("sammamish"))

    get_forecast(lookup_noaa_grid_points(47.675, -122.1215))


if __name__ == "__main__":
    main()
